// app/api/projects/route.ts
import { NextResponse } from "next/server";
import { NextRequest } from "next/server";
import { supabaseAdmin } from "@/lib/supabaseAdmin";
import { verifyAuth, canModifyProject } from '@/lib/auth';

type DbProject = {
  id: string;
  name: string;
  description: string | null;
  created_at: string;
};

/**
 * GET /api/projects
 * Ritorna la lista dei progetti da Supabase
 * Usa il service role per bypassare RLS
 */
export async function GET(req: Request) {
  try {
    console.log('[GET /api/projects] Request started');

    // Quick debug: log incoming host and auth headers (no secrets printed)
    const url = new URL(req.url);
    const isDebug = url.searchParams.get('debug') === '1' || req.headers.get('x-debug') === '1';
    console.log('[GET /api/projects] Fetching projects from Supabase... host=', url.host, 'debug=', isDebug);
    if (isDebug) {
      console.log('[GET /api/projects] Incoming headers (x-actor-id, authorization present):', {
        'x-actor-id': Boolean(req.headers.get('x-actor-id')),
        'authorization_present': Boolean(req.headers.get('authorization'))
      });
    }
    
    // If caller provides an actor id (x-actor-id) return two lists: my_projects and shared_with_me
    let actorId = req.headers.get('x-actor-id');
    // If header contains an email or non-UUID, try to resolve it to a UID
    if (actorId) {
      const resolved = await resolveActorId(actorId);
      if (resolved) actorId = resolved;
    }

    // If no explicit actor id, try Authorization Bearer token
    if (!actorId) {
      const authHeader = req.headers.get('authorization') || '';
      if (authHeader.toLowerCase().startsWith('bearer ')) {
        const token = authHeader.split(' ')[1];
        try {
          const { data: verified, error: verifyErr } = await supabaseAdmin.auth.getUser(token as string);
          if (!verifyErr && verified?.user?.id) actorId = verified.user.id;
          else console.warn('[GET /api/projects] auth.getUser failed', verifyErr?.message || verifyErr);
        } catch (e) {
          console.warn('[GET /api/projects] token verification error', e?.message || e);
        }
      }
    }

    // If still no actorId, try to extract an access token from cookies (common cookie names)
    if (!actorId) {
      try {
        const cookieHeader = req.headers.get('cookie') || '';
        if (cookieHeader) {
          // Common Supabase cookie names and patterns
          const keys = ['sb-access-token', 'supabase-auth-token', 'access_token', 'token', 'sb:token'];
          const pairs = cookieHeader.split(';').map(s => s.trim());
          for (const pair of pairs) {
            const eq = pair.indexOf('=');
            if (eq === -1) continue;
            const k = pair.substring(0, eq).trim();
            const v = pair.substring(eq + 1).trim();
            if (keys.includes(k) && v) {
              // cookie may be URL encoded or JSON; try to parse JSON
              let cand = v;
              try {
                cand = decodeURIComponent(v);
              } catch (e) {}
              if (cand.startsWith('{')) {
                try {
                  const parsed = JSON.parse(cand);
                  // supabase session shapes may contain access_token
                  if (parsed?.access_token) {
                    const { data: verified, error: verifyErr } = await supabaseAdmin.auth.getUser(parsed.access_token);
                    if (!verifyErr && verified?.user?.id) { actorId = verified.user.id; break; }
                  }
                } catch (e) {}
              } else {
                // try token-like string
                const jwtMatch = cand.match(/([A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+)/);
                const token = jwtMatch ? jwtMatch[1] : cand;
                try {
                  const { data: verified, error: verifyErr } = await supabaseAdmin.auth.getUser(token as string);
                  if (!verifyErr && verified?.user?.id) { actorId = verified.user.id; break; }
                } catch (e) {}
              }
            }
          }
        }
      } catch (e) {
        // ignore cookie parsing issues
      }
    }

    if (!actorId) {
      console.log('[GET /api/projects] No actor header or valid token provided — returning public projects list');
    } else {
      console.log('[GET /api/projects] Resolved actorId=', actorId);
    }

    if (actorId) {
      // My projects: where owner_id == actorId
      const { data: myProjects, error: myErr } = await supabaseAdmin
        .from('projects')
        .select('*')
        .eq('owner_id', actorId)
        .order('created_at', { ascending: false });

      if (myErr) {
        console.error('[GET /api/projects] Error loading my projects:', myErr);
        return NextResponse.json({ error: myErr.message }, { status: 500 });
      }

      // Shared: projects where user is in project_members OR is member of a team that owns the project,
      // excluding projects the user already owns
      // 1) project_members
      const { data: pmRows, error: pmErr } = await supabaseAdmin
        .from('project_members')
        .select('project_id, role')
        .eq('member_id', actorId);

      if (pmErr) {
        console.error('[GET /api/projects] Error loading project_members:', pmErr);
        return NextResponse.json({ error: pmErr.message }, { status: 500 });
      }

      const projectIdsFromMembers = (pmRows || []).map((r: any) => r.project_id).filter(Boolean);

      // 2) team_members -> collect team ids
      const { data: tmRows, error: tmErr } = await supabaseAdmin
        .from('team_members')
        .select('team_id')
        .eq('user_id', actorId);

      if (tmErr) {
        console.error('[GET /api/projects] Error loading team_members:', tmErr);
        return NextResponse.json({ error: tmErr.message }, { status: 500 });
      }

      const teamIds = (tmRows || []).map((t: any) => t.team_id).filter(Boolean);

      // Collect shared project ids from team membership
      let projectIdsFromTeams: string[] = [];
      if (teamIds.length) {
        const { data: projectsFromTeams, error: pftErr } = await supabaseAdmin
          .from('projects')
          .select('id')
          .in('team_id', teamIds);

        if (pftErr) {
          console.error('[GET /api/projects] Error loading projects for teams:', pftErr);
          return NextResponse.json({ error: pftErr.message }, { status: 500 });
        }

        projectIdsFromTeams = (projectsFromTeams || []).map((p: any) => p.id).filter(Boolean);
      }

      const sharedIdsSet = new Set<string>([...projectIdsFromMembers, ...projectIdsFromTeams]);
      // Remove projects owned by actor
      const ownedIds = new Set((myProjects || []).map((p: any) => p.id));
      const finalSharedIds = Array.from(sharedIdsSet).filter((id) => !ownedIds.has(id));

      let sharedProjects: any[] = [];
      if (finalSharedIds.length) {
        const { data: sp, error: spErr } = await supabaseAdmin
          .from('projects')
          .select('*')
          .in('id', finalSharedIds)
          .order('created_at', { ascending: false });

        if (spErr) {
          console.error('[GET /api/projects] Error loading shared projects:', spErr);
          return NextResponse.json({ error: spErr.message }, { status: 500 });
        }

        sharedProjects = sp || [];
      }

      // For each project include team_members minimal info
      const hydrate = async (projectsList: any[]) => {
        return Promise.all(
          (projectsList || []).map(async (project) => {
            let teamMembersData: any[] = [];
            try {
              if (project.team_id) {
                const { data } = await supabaseAdmin
                  .from('team_members')
                  .select('user_id, role, joined_at')
                  .eq('team_id', project.team_id);
                teamMembersData = data || [];
              }
            } catch (e: any) {
              console.warn('[GET /api/projects] Warning loading team_members for project', project.id, e?.message || e);
            }
            return { ...project, team_members: teamMembersData };
          })
        );
      };

      const myProjectsHydrated = await hydrate(myProjects || []);
      const sharedHydrated = await hydrate(sharedProjects || []);

      // Maintain backward compatibility: include a combined `projects` array
      const combined = [...(myProjectsHydrated || []), ...(sharedHydrated || [])];

      const body = { my_projects: myProjectsHydrated, shared_with_me: sharedHydrated, projects: combined };
      if (isDebug) body['__debug'] = { resolved_actor_id: actorId };
      return NextResponse.json(body, { status: 200 });
    }

    // Fallback: return all projects (existing behavior)
    const { data: projectsData, error: projectsError } = await supabaseAdmin
      .from('projects')
      .select('*')
      .order('created_at', { ascending: false });

    if (projectsError) {
      console.error('[GET /api/projects] Error loading projects:', projectsError);
      return NextResponse.json({ error: projectsError.message, code: projectsError.code }, { status: 500 });
    }

    const projects = await Promise.all(
          (projectsData || []).map(async (project: any) => {
        let teamMembersData: any[] = [];
        try {
          if (project.team_id) {
            const { data } = await supabaseAdmin
              .from('team_members')
              .select('user_id, role, joined_at')
              .eq('team_id', project.team_id);
            teamMembersData = data || [];
          }
        } catch (e: any) {
          console.warn('[GET /api/projects] Warning loading team_members for project', project.id, e?.message || e);
        }

        return { ...project, team_members: teamMembersData };
      })
    );

    const respBody: any = { projects };
    if (isDebug) respBody['__debug'] = { resolved_actor_id: null };
    return NextResponse.json(respBody, { status: 200, headers: { 'Content-Type': 'application/json' } });
  } catch (err: any) {
    console.error("[GET /api/projects] Exception:", {
      message: err?.message,
      stack: err?.stack
    });
    return NextResponse.json(
      {
        error: err?.message || "Errore imprevisto",
        details: String(err),
      },
      { status: 500 }
    );
  }
}

/**
 * POST /api/projects
 * Crea un nuovo progetto su Supabase
 * Body JSON: { title: string, description?: string, team_id: string }
 */
export async function POST(req: Request) {
  try {
    const rawBody = await req.text();

    if (!rawBody) {
      console.error("[POST /api/projects] Empty request body");
      return NextResponse.json(
        { error: "Empty request body" },
        { status: 400 }
      );
    }

    let body: any;
    try {
      body = JSON.parse(rawBody);
    } catch (err) {
      console.error(
        "[POST /api/projects] JSON parse error",
        err,
        "RAW:",
        rawBody
      );
      return NextResponse.json(
        { error: "Invalid JSON body" },
        { status: 400 }
      );
    }

    const rawName = typeof body.name === "string" ? body.name : "";
    const rawDescription =
      typeof body.description === "string" ? body.description : "";
    let teamId = typeof body.team_id === "string" ? body.team_id : "";

    const name = rawName.trim();
    const description = rawDescription.trim();

    if (!name) {
      return NextResponse.json(
        { error: "Name is required" },
        { status: 400 }
      );
    }

    // Determine actor (owner) from Authorization or x-actor-id header
    let actorId = req.headers.get('x-actor-id') || null;
    try {
      const authHeader = req.headers.get('authorization') || '';
      if (authHeader.toLowerCase().startsWith('bearer ')) {
        const token = authHeader.split(' ')[1];
        if (token) {
          const { data: verified, error: verifyErr } = await supabaseAdmin.auth.getUser(token);
          if (!verifyErr && verified?.user?.id) actorId = verified.user.id;
          else console.warn('[/api/projects] auth.getUser failed', verifyErr);
        }
      }
    } catch (e) {
      console.warn('[/api/projects] token verification error', e);
    }

    // If team_id is 'auto' or missing, get first team from DB or create one
    if (!teamId || teamId === 'auto') {
      console.log('[POST /api/projects] Auto-creating workspace');
      
      // Try to find existing team
      const { data: existingTeams } = await supabaseAdmin
        .from('teams')
        .select('id')
        .limit(1);
      
      if (existingTeams && existingTeams.length > 0) {
        teamId = existingTeams[0].id;
        console.log('[POST /api/projects] Using existing team:', teamId);
      } else {
        // Create new team
        const { data: newTeam, error: teamError } = await supabaseAdmin
          .from('teams')
          .insert({ name: 'Personal Workspace', owner_id: actorId || 'system' })
          .select()
          .single();
        
        if (teamError) {
          console.error('[POST /api/projects] Error creating team:', teamError);
          return NextResponse.json(
            { error: 'Failed to create workspace' },
            { status: 500 }
          );
        }
        
        teamId = newTeam.id;
        console.log('[POST /api/projects] Created new team:', teamId);
      }
    }

    // Include owner_id if we determined an actor
    const projectInsert: any = { name, description: description || null, team_id: teamId };
    if (actorId) projectInsert.owner_id = actorId;

    const { data, error } = await supabaseAdmin
      .from("projects")
      .insert(projectInsert)
      .select("id, name, description, created_at, team_id, owner_id")
      .single();

    if (error) {
      console.error("[POST /api/projects] Supabase insert error", error);
      return NextResponse.json(
        {
          error:
            error.message || "Errore nella creazione del progetto su Supabase",
          details: error,
        },
        { status: 500 }
      );
    }

    // If we created the project and we know the owner, add membership row
    try {
      if (actorId && data?.id) {
        await supabaseAdmin.from('project_members').upsert({ project_id: data.id, member_id: actorId, role: 'owner', added_by: actorId }, { onConflict: '(project_id, member_id)' });
      }
    } catch (e) {
      console.warn('[POST /api/projects] Warning adding project_members for owner', e);
    }

    return NextResponse.json({ project: data as DbProject }, { status: 201 });
  } catch (err: any) {
    console.error("[POST /api/projects] Unexpected error", err);
    return NextResponse.json(
      {
        error:
          err?.message || "Errore imprevisto nella creazione del progetto",
        details: String(err),
      },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/projects
 * Aggiorna titolo e descrizione
 * Body JSON: { id: string, title?: string, description?: string }
 */
export async function PATCH(req: Request) {
  try {
    const rawBody = await req.text();

    if (!rawBody) {
      console.error("[PATCH /api/projects] Empty request body");
      return NextResponse.json(
        { error: "Empty request body" },
        { status: 400 }
      );
    }

    let body: any;
    try {
      body = JSON.parse(rawBody);
    } catch (err) {
      console.error(
        "[PATCH /api/projects] JSON parse error",
        err,
        "RAW:",
        rawBody
      );
      return NextResponse.json(
        { error: "Invalid JSON body" },
        { status: 400 }
      );
    }

    const id = typeof body.id === "string" ? body.id : "";
    const rawName = typeof body.name === "string" ? body.name : "";
    const rawDescription =
      typeof body.description === "string" ? body.description : "";
    const deleteCueId = typeof body.deleteCueId === "string" ? body.deleteCueId : "";

    if (!id) {
      return NextResponse.json(
        { error: "id is required" },
        { status: 400 }
      );
    }

    // Handle cue deletion
    if (deleteCueId) {
      console.log("[PATCH /api/projects] Deleting cue:", deleteCueId);
      const { error: deleteError } = await supabaseAdmin
        .from("cues")
        .delete()
        .eq("id", deleteCueId)
        .eq("project_id", id);

      if (deleteError) {
        console.error("[PATCH /api/projects] Supabase cue delete error", deleteError);
        return NextResponse.json(
          {
            error: deleteError.message || "Errore nella cancellazione della cue",
            details: deleteError,
          },
          { status: 500 }
        );
      }

      return NextResponse.json({ success: true, message: "Cue deleted" }, { status: 200 });
    }

    const update: { name?: string; description?: string | null } = {};

    if (rawName.trim()) update.name = rawName.trim();
    if (rawDescription.trim()) update.description = rawDescription.trim();

    if (!Object.keys(update).length) {
      return NextResponse.json(
        { error: "Nothing to update" },
        { status: 400 }
      );
    }

    const { data, error } = await supabaseAdmin
      .from("projects")
      .update(update)
      .eq("id", id)
      .select("id, name, description, created_at")
      .single();

    if (error) {
      console.error("[PATCH /api/projects] Supabase update error", error);
      return NextResponse.json(
        {
          error: error.message || "Errore nell'aggiornamento del progetto",
          details: error,
        },
        { status: 500 }
      );
    }

    return NextResponse.json({ project: data as DbProject }, { status: 200 });
  } catch (err: any) {
    console.error("[PATCH /api/projects] Unexpected error", err);
    return NextResponse.json(
      {
        error:
          err?.message || "Errore imprevisto nell'aggiornamento del progetto",
        details: String(err),
      },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/projects
 * Cancella un progetto.
 * Può ricevere l'id sia nel body JSON { id } sia come query string ?id=...
 */
export async function DELETE(req: Request) {
  try {
    const url = new URL(req.url);
    const queryId = url.searchParams.get("id") ?? "";

    const rawBody = await req.text();

    let body: any = null;
    if (rawBody) {
      try {
        body = JSON.parse(rawBody);
      } catch (err) {
        console.error(
          "[DELETE /api/projects] JSON parse error",
          err,
          "RAW:",
          rawBody
        );
        // Se il body è invalido ma abbiamo queryId, possiamo comunque procedere.
      }
    }

    const bodyId =
      body && typeof body.id === "string" ? body.id.trim() : "";

    const id = bodyId || queryId;

    if (!id) {
      return NextResponse.json(
        { error: "id is required" },
        { status: 400 }
      );
    }

    const { error } = await supabaseAdmin.from("projects").delete().eq("id", id);

    if (error) {
      console.error("[DELETE /api/projects] Supabase delete error", error);
      return NextResponse.json(
        {
          error:
            error.message || "Errore nella cancellazione del progetto",
          details: error,
        },
        { status: 500 }
      );
    }

    return NextResponse.json({ success: true }, { status: 200 });
  } catch (err: any) {
    console.error("[DELETE /api/projects] Unexpected error", err);
    return NextResponse.json(
      {
        error:
          err?.message ||
          "Errore imprevisto nella cancellazione del progetto",
        details: String(err),
      },
      { status: 500 }
    );
  }
}
