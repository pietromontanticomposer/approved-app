{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/pietromontanti/Desktop/approved-clean/Approved/lib/supabaseAdmin.ts"],"sourcesContent":["import { createClient } from \"@supabase/supabase-js\";\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\n// Export a variable and assign it below to avoid `export` inside conditionals\nexport let supabaseAdmin: any = null;\n\n// If real env vars are present, use real client. Otherwise, if testing is enabled,\n// provide a lightweight in-memory fake client to allow local tests without secrets.\nif (supabaseUrl && supabaseServiceKey) {\n  // Admin client â€” use only on the server\n  supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {\n    auth: { persistSession: false },\n  });\n} else if (process.env.APP_ALLOW_FAKE_SUPABASE === '1') {\n  // Simple in-memory fake DB with minimal API surface used by the server routes.\n  type Row = Record<string, any>;\n  const db: Record<string, Row[]> = {\n    projects: [\n      { id: 'p1', team_id: 't1', owner_id: 'owner-1', name: 'Test Project' },\n    ],\n    share_links: [],\n    project_members: [],\n    team_members: [ { team_id: 't1', user_id: 'owner-1', role: 'owner' } ],\n    audit_logs: [],\n  };\n\n  const { v4: uuidv4 } = require('uuid');\n  function clone(obj: any) { return JSON.parse(JSON.stringify(obj)); }\n\n  function createFrom(tableName: string) {\n    const q: any = {\n      _table: tableName,\n      _select: '*',\n      _where: [] as Array<{k:string,v:any}>,\n      _limit: null as number | null,\n      select(cols?: string) { q._select = cols || '*'; return q; },\n      eq(k: string, v: any) { q._where.push({k,v}); return q; },\n      limit(n: number) { q._limit = n; return q; },\n      maybeSingle: async () => {\n        const rows = db[tableName] || [];\n        const filtered = rows.filter(r => q._where.every(w => String(r[w.k]) === String(w.v)));\n        return { data: filtered.length>0 ? clone(filtered[0]) : null, error: null };\n      },\n      insert: (payload: any) => {\n        const rows = db[tableName] || (db[tableName] = []);\n        const toInsert = Array.isArray(payload) ? payload : [payload];\n        const inserted = toInsert.map((p: any) => {\n          const row = Object.assign({}, p);\n          if (!row.id) row.id = uuidv4();\n          row.created_at = new Date().toISOString();\n          rows.push(row);\n          return row;\n        });\n        return {\n          data: inserted,\n          error: null,\n          select: () => ({\n            single: async () => ({ data: inserted[0], error: null })\n          })\n        };\n      },\n      update: (payload: any) => {\n        // return chainable object supporting .eq(k,v)\n        return {\n          eq: async (k: string, v: any) => {\n            const rows = db[tableName] || [];\n            let updatedCount = 0;\n            for (const r of rows) {\n              if (q._where.every(w => String(r[w.k]) === String(w.v)) && String(r[k]) === String(v)) {\n                Object.assign(r, payload);\n                updatedCount++;\n              }\n            }\n            return { data: updatedCount>0 ? rows.filter(r => (q._where.every(w => String(r[w.k]) === String(w.v)) && String(r[k]) === String(v))) : [], error: null };\n          }\n        };\n      },\n      upsert: async (payload: any, opts?: any) => {\n        const rows = db[tableName] || (db[tableName] = []);\n        // naive onConflict by project_id,member_id\n        const existing = rows.find(r => r.project_id === payload.project_id && r.member_id === payload.member_id);\n        if (existing) {\n          Object.assign(existing, payload);\n          return { data: [existing], error: null };\n        }\n        const row = Object.assign({}, payload);\n        if (!row.id) row.id = uuidv4();\n        rows.push(row);\n        return { data: [row], error: null };\n      },\n      single: async () => {\n        const rows = db[tableName] || [];\n        const filtered = rows.filter(r => q._where.every(w => String(r[w.k]) === String(w.v)));\n        return { data: filtered[0] || null, error: null };\n      }\n    };\n    return q;\n  }\n\n  const fakeAdmin = {\n    from: (table: string) => createFrom(table),\n  };\n\n  supabaseAdmin = fakeAdmin as any;\n} else {\n  throw new Error(\n    \"Missing NEXT_PUBLIC_SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY in environment. Set APP_ALLOW_FAKE_SUPABASE=1 to enable a local fake client for tests.\"\n  );\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 211, "column": 0}, "map": {"version":3,"sources":["file:///Users/pietromontanti/Desktop/approved-clean/Approved/lib/actorResolver.ts"],"sourcesContent":["import { supabaseAdmin } from './supabaseAdmin';\n\n// Resolve a possible actor identifier (could be UID or email) to a Supabase UID.\nexport async function resolveActorId(candidate: string | null): Promise<string | null> {\n  if (!candidate) return null;\n\n  // If the candidate is an Authorization header value like \"Bearer <token>\",\n  // try to resolve the token to a user via the admin client.\n  const maybeBearer = String(candidate || '').trim();\n  if (/^Bearer\\s+/i.test(maybeBearer)) {\n    const token = maybeBearer.split(/\\s+/)[1];\n    if (token) {\n      try {\n        const { data, error } = await supabaseAdmin.auth.getUser(token as string);\n        if (!error && data?.user?.id) return data.user.id;\n      } catch (e) {\n        // ignore\n      }\n    }\n  }\n\n  // If it already looks like a UUID, assume it's a UID\n  const uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/;\n  if (uuidRegex.test(candidate)) return candidate;\n\n  // If it looks like an email, try to find the user by email using admin API\n  if (candidate.includes('@')) {\n    try {\n      // Prefer admin.listUsers if available\n      if (supabaseAdmin.auth && supabaseAdmin.auth.admin && typeof supabaseAdmin.auth.admin.listUsers === 'function') {\n        const res = await supabaseAdmin.auth.admin.listUsers({ search: candidate });\n        if (!res.error && res.data && Array.isArray(res.data.users)) {\n          const exact = res.data.users.find((u: any) => (u.email || '').toLowerCase() === candidate.toLowerCase());\n          if (exact) return exact.id;\n        }\n      }\n\n      // Fallback: query auth.users directly\n      try {\n        const { data } = await supabaseAdmin.from('auth.users').select('id,email').eq('email', candidate).limit(1).maybeSingle();\n        if (data && data.id) return data.id;\n      } catch (e) {\n        // ignore\n      }\n    } catch (e) {\n      // ignore lookup errors\n    }\n  }\n\n  return null;\n}\n\n"],"names":[],"mappings":";;;;AAAA;;AAGO,eAAe,eAAe,SAAwB;IAC3D,IAAI,CAAC,WAAW,OAAO;IAEvB,2EAA2E;IAC3E,2DAA2D;IAC3D,MAAM,cAAc,OAAO,aAAa,IAAI,IAAI;IAChD,IAAI,cAAc,IAAI,CAAC,cAAc;QACnC,MAAM,QAAQ,YAAY,KAAK,CAAC,MAAM,CAAC,EAAE;QACzC,IAAI,OAAO;YACT,IAAI;gBACF,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,uIAAa,CAAC,IAAI,CAAC,OAAO,CAAC;gBACzD,IAAI,CAAC,SAAS,MAAM,MAAM,IAAI,OAAO,KAAK,IAAI,CAAC,EAAE;YACnD,EAAE,OAAO,GAAG;YACV,SAAS;YACX;QACF;IACF;IAEA,qDAAqD;IACrD,MAAM,YAAY;IAClB,IAAI,UAAU,IAAI,CAAC,YAAY,OAAO;IAEtC,2EAA2E;IAC3E,IAAI,UAAU,QAAQ,CAAC,MAAM;QAC3B,IAAI;YACF,sCAAsC;YACtC,IAAI,uIAAa,CAAC,IAAI,IAAI,uIAAa,CAAC,IAAI,CAAC,KAAK,IAAI,OAAO,uIAAa,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,KAAK,YAAY;gBAC9G,MAAM,MAAM,MAAM,uIAAa,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC;oBAAE,QAAQ;gBAAU;gBACzE,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,IAAI,IAAI,MAAM,OAAO,CAAC,IAAI,IAAI,CAAC,KAAK,GAAG;oBAC3D,MAAM,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAW,CAAC,EAAE,KAAK,IAAI,EAAE,EAAE,WAAW,OAAO,UAAU,WAAW;oBACrG,IAAI,OAAO,OAAO,MAAM,EAAE;gBAC5B;YACF;YAEA,sCAAsC;YACtC,IAAI;gBACF,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,uIAAa,CAAC,IAAI,CAAC,cAAc,MAAM,CAAC,YAAY,EAAE,CAAC,SAAS,WAAW,KAAK,CAAC,GAAG,WAAW;gBACtH,IAAI,QAAQ,KAAK,EAAE,EAAE,OAAO,KAAK,EAAE;YACrC,EAAE,OAAO,GAAG;YACV,SAAS;YACX;QACF,EAAE,OAAO,GAAG;QACV,uBAAuB;QACzB;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 266, "column": 0}, "map": {"version":3,"sources":["file:///Users/pietromontanti/Desktop/approved-clean/Approved/app/api/comments/route.ts"],"sourcesContent":["// app/api/comments/route.ts\nimport { NextResponse } from \"next/server\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { supabaseAdmin } from \"@/lib/supabaseAdmin\";\nimport { resolveActorId } from '@/lib/actorResolver';\n\nconst isUuid = (value: string) =>\n  typeof value === \"string\" &&\n  /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(\n    value\n  );\n\n/**\n * GET /api/comments?versionId=xxx\n * Ritorna commenti di una versione\n */\nexport async function GET(req: Request) {\n  try {\n    const url = new URL(req.url);\n    const versionId = url.searchParams.get('versionId');\n\n    if (!versionId) {\n      return NextResponse.json({ error: 'versionId required' }, { status: 400 });\n    }\n\n    const { data: comments, error } = await supabaseAdmin\n      .from(\"comments\")\n      .select('*')\n      .eq(\"version_id\", versionId)\n      .order(\"created_at\", { ascending: true });\n\n    if (error) {\n      console.error(\"[GET /api/comments] Error:\", error);\n      return NextResponse.json({ error: error.message }, { status: 500 });\n    }\n\n    return NextResponse.json({ comments: comments || [] }, { status: 200 });\n  } catch (err: any) {\n    console.error(\"[GET /api/comments] Exception:\", err);\n    return NextResponse.json({ error: err.message }, { status: 500 });\n  }\n}\n\nexport async function POST(req: Request) {\n  try {\n    const body = await req.json();\n    console.log('[POST /api/comments] incoming body:', body);\n    const { version_id, time_seconds, author, text } = body;\n\n    if (!version_id || time_seconds === undefined || !text) {\n      return NextResponse.json(\n        { error: \"version_id, time_seconds, and text are required\" },\n        { status: 400 }\n      );\n    }\n\n    if (!isUuid(version_id)) {\n      return NextResponse.json(\n        { error: \"version_id must be a UUID\" },\n        { status: 400 }\n      );\n    }\n\n    // Derive author: prefer explicit body author, but always try to resolve\n    // actor id from headers when available so we can persist ownership.\n    let authorName = author || null;\n    let resolvedActorUid: string | null = null;\n    try {\n      const actorHeader = (req as any).headers?.get\n        ? req.headers.get('x-actor-id') || req.headers.get('x-actor') || null\n        : null;\n\n      const candidate = actorHeader || null;\n      if (candidate) {\n        const resolvedUid = await resolveActorId(candidate);\n        if (resolvedUid) {\n          resolvedActorUid = resolvedUid;\n          // If author wasn't provided, try to derive it from user metadata\n          if (!authorName) {\n            try {\n              const { data: userRow } = await supabaseAdmin\n                .from('auth.users')\n                .select('id, user_metadata')\n                .eq('id', resolvedUid)\n                .maybeSingle();\n\n              if (userRow && userRow.user_metadata) {\n                const meta = userRow.user_metadata as any;\n                const first = meta.first_name || meta.firstName || meta.first || '';\n                const last = meta.last_name || meta.lastName || meta.last || '';\n                const display = meta.display_name || meta.full_name || `${first} ${last}`.trim();\n                if (display) authorName = display;\n              }\n            } catch (e) {\n              // ignore user lookup errors; we'll fall back later\n            }\n          }\n        }\n      }\n    } catch (e) {\n      // ignore resolution errors\n    }\n\n    const comment_id = uuidv4();\n\n    // Debug: log incoming actor header and resolved UID to help diagnose null actor_id\n    try {\n      const actorHeaderDbg = (req as any).headers?.get ? req.headers.get('x-actor-id') || req.headers.get('x-actor') || null : null;\n      console.log('[POST /api/comments] actor header:', actorHeaderDbg, 'resolvedActorUid (pre-insert):', resolvedActorUid);\n    } catch (e) {\n      // ignore\n    }\n\n    // Try inserting including actor_id; if the DB schema doesn't yet contain\n    // actor_id (eg. dev instance without latest migrations) retry without it.\n    let data: any = null;\n    let insertError: any = null;\n    try {\n      const res = await supabaseAdmin\n        .from(\"comments\")\n        .insert({\n          id: comment_id,\n          version_id,\n          time_seconds,\n          author: authorName || \"Client\",\n          actor_id: resolvedActorUid,\n          text,\n        })\n        .select()\n        .single();\n      data = res.data;\n      insertError = res.error;\n    } catch (e: any) {\n      insertError = e;\n    }\n\n    // If the insert failed due to missing actor_id column in schema cache,\n    // retry without actor_id to keep older deployments working.\n    if (insertError) {\n      const msg = (insertError && (insertError.message || insertError.error_description || String(insertError))) || '';\n      if (msg.toLowerCase().includes('actor_id') || msg.toLowerCase().includes('schema cache')) {\n        try {\n          const res2 = await supabaseAdmin\n            .from('comments')\n            .insert({\n              id: comment_id,\n              version_id,\n              time_seconds,\n              author: authorName || 'Client',\n              text,\n            })\n            .select()\n            .single();\n          data = res2.data;\n          insertError = res2.error;\n        } catch (e2: any) {\n          insertError = e2;\n        }\n      }\n    }\n\n    if (insertError) {\n      console.error('[POST /api/comments] Supabase error', insertError);\n      return NextResponse.json({ error: insertError.message || JSON.stringify(insertError) }, { status: 500 });\n    }\n\n    console.log('[POST /api/comments] inserted comment:', data);\n\n    return NextResponse.json({ comment: data }, { status: 201 });\n  } catch (err: any) {\n    console.error(\"[POST /api/comments] Error\", err);\n    return NextResponse.json(\n      { error: err.message || \"Internal error\" },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function PATCH(req: Request) {\n  try {\n    const body = await req.json();\n    const { id, text } = body;\n\n    if (!id || !text) {\n      return NextResponse.json(\n        { error: \"id and text are required\" },\n        { status: 400 }\n      );\n    }\n\n    if (!isUuid(id)) {\n      return NextResponse.json(\n        { error: \"id must be a UUID\" },\n        { status: 400 }\n      );\n    }\n\n    // Resolve actor id from header for authorization\n    const actorHeader = (req as any).headers?.get ? req.headers.get('x-actor-id') || req.headers.get('x-actor') || null : null;\n    const resolvedUid = actorHeader ? await resolveActorId(actorHeader) : null;\n\n    // Fetch the comment to check ownership\n    const { data: existing, error: fetchErr } = await supabaseAdmin\n      .from('comments')\n      .select('id, actor_id')\n      .eq('id', id)\n      .maybeSingle();\n\n    if (fetchErr) {\n      console.error('[PATCH /api/comments] Error fetching comment', fetchErr);\n      return NextResponse.json({ error: fetchErr.message || 'Error fetching comment' }, { status: 500 });\n    }\n\n    if (!existing) {\n      return NextResponse.json({ error: 'Comment not found' }, { status: 404 });\n    }\n\n    // If actor_id is not set on the comment, require migration/backfill\n    if (!existing.actor_id) {\n      return NextResponse.json({ error: \"Comment does not have an actor_id; run migrations/backfill to enable edits/deletes\" }, { status: 403 });\n    }\n\n    if (!resolvedUid || resolvedUid !== existing.actor_id) {\n      return NextResponse.json({ error: 'Not authorized to edit this comment' }, { status: 403 });\n    }\n\n    const { data, error } = await supabaseAdmin\n      .from(\"comments\")\n      .update({ text })\n      .eq(\"id\", id)\n      .select()\n      .single();\n\n    if (error) {\n      console.error(\"[PATCH /api/comments] Supabase error\", error);\n      return NextResponse.json({ error: error.message }, { status: 500 });\n    }\n\n    return NextResponse.json({ comment: data }, { status: 200 });\n  } catch (err: any) {\n    console.error(\"[PATCH /api/comments] Error\", err);\n    return NextResponse.json(\n      { error: err.message || \"Internal error\" },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function DELETE(req: Request) {\n  try {\n    const { searchParams } = new URL(req.url);\n    const id = searchParams.get(\"id\");\n\n    if (!id) {\n      return NextResponse.json(\n        { error: \"id query parameter is required\" },\n        { status: 400 }\n      );\n    }\n\n    if (!isUuid(id)) {\n      return NextResponse.json(\n        { error: \"id must be a UUID\" },\n        { status: 400 }\n      );\n    }\n\n    // Resolve actor id from header for authorization\n    const actorHeader = (req as any).headers?.get ? req.headers.get('x-actor-id') || req.headers.get('x-actor') || null : null;\n    const resolvedUid = actorHeader ? await resolveActorId(actorHeader) : null;\n\n    // Fetch the comment to check ownership\n    const { data: existing, error: fetchErr } = await supabaseAdmin\n      .from('comments')\n      .select('id, actor_id')\n      .eq('id', id)\n      .maybeSingle();\n\n    if (fetchErr) {\n      console.error('[DELETE /api/comments] Error fetching comment', fetchErr);\n      return NextResponse.json({ error: fetchErr.message || 'Error fetching comment' }, { status: 500 });\n    }\n\n    if (!existing) {\n      return NextResponse.json({ error: 'Comment not found' }, { status: 404 });\n    }\n\n    if (!existing.actor_id) {\n      return NextResponse.json({ error: \"Comment does not have an actor_id; run migrations/backfill to enable edits/deletes\" }, { status: 403 });\n    }\n\n    if (!resolvedUid || resolvedUid !== existing.actor_id) {\n      return NextResponse.json({ error: 'Not authorized to delete this comment' }, { status: 403 });\n    }\n\n    const { error } = await supabaseAdmin\n      .from(\"comments\")\n      .delete()\n      .eq(\"id\", id);\n\n    if (error) {\n      console.error(\"[DELETE /api/comments] Supabase error\", error);\n      return NextResponse.json({ error: error.message }, { status: 500 });\n    }\n\n    return NextResponse.json({ success: true }, { status: 200 });\n  } catch (err: any) {\n    console.error(\"[DELETE /api/comments] Error\", err);\n    return NextResponse.json(\n      { error: err.message || \"Internal error\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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"}}]
}